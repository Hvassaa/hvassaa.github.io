window.SIDEBAR_ITEMS = {"fn":[["add_polyx","Add two polynomials, return resulting polynomial"],["add_scalar_polyx","Add a scalar (constant) from a polynomial, return resulting polynomial"],["calculate_L_or_R","Auxilary function for computing L_j or R_j in step 24"],["check_equal_polyx",""],["check_not_zero_polyx","Checks if all entries in a polynomial is 0"],["commit_polyx","Pedersen vector commitment"],["compute_vanishing_polynomial","Compute vanishing polynomial over n-order multiplicative subgroup H with root of unity omega"],["degree_polyx","Get the degree of a polynomial"],["divide_leading_terms","divide the leading terms of two polynomials, returning a single term (e.g. 5x^3) represented as a polynomial (helper function for divide_poly)"],["divide_polyx","Perform polynomial long division, returning the quotient and the remainder. The algorithm is from https://en.wikipedia.org/wiki/Polynomial_long_division."],["eval_polyx","Evaluate a polynomial at point, return the evaluation"],["gen_one_polyx",""],["gen_zero_polyx",""],["inner_product","Inner product, between to equal length vectors of field elements"],["lagrange_basis","Finds the Lagrange basis for a set of `points` and a single evaluation point `x` This will produce a polynomial that evaluates to 1 at `x`and to 0 at all other x-values in the set `points` No other guarentees are given about the resulting polynomial"],["lagrange_polyx","Find lowest degree polynomial passing through a set points using legrange interpolation"],["msm","Multiscalar multiplicatoin, auxiliary function for Pedersen vector commitment"],["mul_polyx","Polynomial multiplication using sparse multiplication. This can be more efficient than operand scanning but also prone to side-channel attacks. Mostly copied from hacspec’s poly_mul"],["mul_scalar_polyx","Multiply a polynomial by a scalar, return resulting polynomial"],["multi_poly_with_x","Wrapper function for multiplying a polynomial with the indeterminate"],["multi_poly_with_x_pow","Wrapper function for multiplying a polynomial with the indeterminate multiple times"],["rotate_polyx","Rotate a polynomial"],["sigma","Implementation of the σ mapping from the protocol"],["step_10","Step 10 This function initializes the s sequence of length n_a and fills it with polynomials of degree n_e-1 made with legrange interpolation"],["step_11","Step 11 Get the list of Q’s (Q_0, …, Q_{n_q - 1})"],["step_12","Step 12 Get the list of q’s (q_0, …, q_{n_q - 1}) and q_blinds (accumulated blindness)"],["step_13","Step 13 Get the list of r’s (r_0, …, r_{n_q - 1})"],["step_14","Step 14 Get the commitment Q’, poly q’ and the blindness used"],["step_15","Step 15 This function emulates sending a challenge."],["step_16","Step 16 Get the u ∈ F^{n_q} vector"],["step_17","Step 17 This function emulates sending a challenge."],["step_18","Step 18 Get P and the v"],["step_19","Step 19 Get the p(X) polynomial"],["step_20","Step 20 Get the commitment S and the blindness used"],["step_21","Step 21 Get the xi and z challenges. They have to be fed into hacspec, since there is no randomness."],["step_22","Step 22 Get the P’ curve-point/group-element"],["step_23","Step 23 Get the p’(X) polynomial and p’ blindness"],["step_24","Step 24 Get G‘, p’, b, L, R, and {L,R} blinds"],["step_25","Step 25 Get the zeroth entry in p and synthetic blinding factor f"],["step_26","Step 26 Verifiers final check of the protocol"],["step_4","Step 4 Beginning of the vanishing argument"],["step_5","Step 5 split polynomial of degree n_g(n-1)-n up into n_(g-2) polynomials of degree at most n-1"],["step_6","Step 6 commit to each h_i polynomial keeping them in the seq to peserve the power (i)"],["step_7","Step 7 Computes the sum from step 7 in the protocol description"],["step_8","Step 8 This functions calculates h’(X) from the h_i parts created in step 5 and the challenge x"],["step_9","Step 9 This functions returns r(x) and creates a seq filled with a_i from the second part of step 9"],["sub_polyx","Subtract two polynomials, return resulting polynomial"],["sub_scalar_polyx","Subtract a scalar (constant) from a polynomial, return resulting polynomial"],["trim_polyx","Trim a polynomial of trailing zeros (zero-terms) and return it"]],"type":[["CRS","Common Reference Struct"],["Polyx","A polynomial represented by its coefficient form, such that index i is the i’th term"]]};